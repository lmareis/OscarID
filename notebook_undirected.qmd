---
bibliography: references.bib 
authors:
  - name: Leopold Mareis
    orcid: 0000-0002-2624-6522
    affiliation: "Technical University of Munich "
    country: Germany
  - name: Anthony Della Vecchia
    orcid: 0009-0008-1179-9862
    affiliation: "TU Berlin"
  - name: Bejamin Hollering
    orcid: 0000-0003-3803-2879
    affiliation: "Max Planck Institute for Mathematics in the Sciences"
engine: julia
---

# Generic Identification in Gaussian Graphical Models with OSCAR

| Resource | Information |
|------------------------------------|------------------------------------|
| Git + DOI | [Git](https://github.com/lmareis/OscarID) [Zenodo.18709429](https://doi.org/10.5281/zenodo.18709429) |
| Short Description | This notebook demonstrates the computational algebraic procedure in OSCAR to determine the identifiability of model parameters in Gaussian graphical models. |

: {.striped}

```{julia}
using Oscar
```

### Identification in OSCAR

```{julia}
#| output: false
function identify_parameters(M::GraphicalModel, 
                             return_elimination_ideal = false,
                             return_ideal = false)

  # get graph data from the model
  G = graph(M)
  if typeof(G) === Oscar.MixedGraph
    E = edges(G, Directed)
  else
    E = edges(G)
  end
  
  # get rings and parametrization
  S, s = model_ring(M)
  R, t = parameter_ring(M)
  phi = parametrization(M)
  
  # setup the elimination ideal
  elim_ring, elim_gens = polynomial_ring(coefficient_ring(R), vcat(symbols(R), symbols(S)))
  inject_R = hom(R, elim_ring, elim_gens[1:ngens(R)])
  inject_S = hom(S, elim_ring, elim_gens[ngens(R) + 1:ngens(elim_ring)])
  I = ideal([
    inject_S(s) * inject_R(denominator(phi(s))) - inject_R(numerator(phi(s))) for s in gens(S)
  ])
  if return_ideal
    return I
  end
  
  # eliminate
  out = Dict()
  for e in E
    l = t[e]
    other_params = [inject_R(i) for i in values(t) if i != l]
    J = eliminate(I, other_params)
    if return_elimination_ideal
      out[e] = J
    else
      out[e] = contains_linear_poly(J, inject_R(l), ngens(R))
    end
  end
  
  return out
end

function print_dictionary(out::Dict{Any, Any})
    for (i, edge) in enumerate(keys(out))
        println(edge)
        show(stdout, "text/plain", out[edge])
        println()
        if i < length(out)
            println()
        end
    end
end
```

```{julia}
#| output: false
function contains_linear_poly(J::MPolyIdeal, l::MPolyRingElem, nparams::Int)

  R = base_ring(J)
  
  for f in gens(J)
    exps = exponents(f)
    for v in exps
      # check for ideal generator with only one of its monomials containing 
      # l and with degree 1
      if v[var_index(l)] == 1 && sum(sum(e[1:nparams]) for e in exps) == 1
        return (true, f)
      end
    end
  end
  
  return (false, R(0))
end
```

## Undirected Graphs

For undirected graphical modelling, assume the three-variate random vector $X$ be Markov to the following graph:

![](Tikz_Pictures/Graph.png){fig-align="center" width="200"}

```{julia}
G = graph_from_edges(Undirected, [[1, 2], [2, 3]])
M = gaussian_graphical_model(G)
out = identify_parameters(M)
print_dictionary(out)
```

This model does not allow for any parameter identifiaction. The reason being that there exists a degree of freedom in scaling the precision matrix parameters $K = \Sigma^{-1}$ that returns the same covariance matrix.
One possibility to restrict the model class is through coloring (@boege2025coloured).

### Colored Undirected Graphs

Coloring graphs couples parameters. For example, we assume in the graph below that the error variance on all components is equal. This is indicated by the red coloring.

![](Tikz_Pictures/Graph_color.png){fig-align="center" width="200"}

Computationally, coloring the graphs requires overloading the function `parameter ring` in `Oscar` (@boege2026algebraic).

```{julia}
#| output: false
import Oscar: parameter_ring, GraphDict, GraphMap

const ColoredGGM{Undirected} = GaussianGraphicalModel{
  Graph{Undirected}, @NamedTuple{color::GraphMap{Undirected}}
}

@attr Tuple{
  QQMPolyRing,
  GraphDict{QQMPolyRingElem}
} function parameter_ring(GM::ColoredGGM{Undirected})
  G = graph(GM)
  colors = unique([
    [G.color[e] for e in edges(G)]; [G.color[v] for v in vertices(G)]
  ])
  R, x = polynomial_ring(QQ, varnames(GM)[:k] => colors)
  color_dict = Dict{String, MPolyRingElem}(
    color => x[i] for (i, color) in enumerate(colors))

  gens_dict = GraphDict{QQMPolyRingElem}(
    Dict{Union{Int, Edge}, QQMPolyRingElem}(merge(
      Dict(e => color_dict[G.color[e]] for e in edges(G)),
      Dict(v => color_dict[G.color[v]] for v in vertices(G))
  )))
    
  return R, gens_dict
end
```

```{julia}
G = graph_from_labeled_edges(Dict((1, 2) => "2, 1", (2, 3) => "3, 2"),
                             Dict(1 => "red", 2 => "red", 3 => "red"); 
                             name=:color)
M = gaussian_graphical_model(G)
K = concentration_matrix(M)
show(stdout, "text/plain", K); println(); println()

out = identify_parameters(M)
print_dictionary(out)
```

Both parameters, $k_{21}$ and $k_{32}$ are now identifiable.

# Example with latent variable
